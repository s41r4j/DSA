# [ Data Structures & Algorithms ] 

```
DSA
├── Data Structures
│   ├── Array
│   │   ├── Static Array
│   │   ├── Dynamic Array
│   │   ├── Sparse Array
│   │   ├── Bit Array
│   │   ├── Circular Array
│   │   └── Jagged Array
│   ├── String
│   ├── Linked List
│   │   ├── Singly Linked List
│   │   ├── Doubly Linked List
│   │   ├── Circular Linked List
│   │   └── Skip List
│   ├── Stacks
│   │   ├── Array-based Stack
│   │   ├── Linked List-based Stack
│   │   ├── Dynamic Stack
│   │   ├── Undo Stack
│   │   ├── Expression Evaluation Stack
│   │   └── Minimum Element Stack
│   ├── Queue
│   │   ├── Queue (Array-based)
│   │   ├── Queue (Linked List-based)
│   │   ├── Priority Queue
│   │   ├── Double-ended Queue (Deque)
│   │   └── Circular Queue
│   │   ├── Bounded Priority Queue
│   │   └── Concurrent Queue
│   ├── Heap
│   │   ├── Binary Heap
│   │   ├── Fibonacci Heap
│   │   └── Binomial Heap
│   ├── Hash Table
│   ├── Tree Data Structures
│   │   ├── Binary Tree
│   │   ├── Binary Search Tree
│   │   ├── AVL Tree
│   │   ├── Red-Black Tree
│   │   ├── B-tree
│   │   ├── Splay Tree
│   │   ├── Trie
│   │   ├── Segment Tree
│   │   ├── Fenwick Tree (Binary Indexed Tree)
│   │   ├── Disjoint Set (Union-Find)
│   │   └── Suffix Tree
│   └── Graph Data Structure
│       ├── Graph Representation
│       ├── Graph Traversals
│       ├── Depth-First Search (DFS)
│       ├── Breadth-First Search (BFS)
│       ├── Topological Sorting
│       ├── Minimum Spanning Tree (MST)
│       ├── Shortest Path Algorithms
│       ├── Strongly Connected Components (SCC)
│       ├── Articulation Points and Bridges
│       ├── Directed Acyclic Graph (DAG)
│       ├── Graph Coloring
│       ├── Network Flow
│       ├── Cut Vertices (Cut Points)
│       ├── Eulerian Path and Circuit
│       ├── Hamiltonian Path and Circuit
│       ├── Bipartite Graph
│       ├── Planar Graph
│       ├── Maximum Flow
│       ├── Maximum Bipartite Matching
│       ├── Minimum Cut
│       └── Travelling Salesman Problem (TSP)
├── Algorithms
│   ├── Searching Algorithms
│   │   ├── Linear Search
│   │   ├── Binary Search
│   │   ├── Interpolation Search
│   │   ├── Exponential Search
│   │   ├── Ternary Search
│   │   ├── Jump Search
│   │   └── Hashing
│   ├── Sorting Algorithms
│   │   ├── Bubble Sort
│   │   ├── Selection Sort
│   │   ├── Insertion Sort
│   │   ├── Merge Sort
│   │   ├── Quick Sort
│   │   ├── Heap Sort
│   │   ├── Radix Sort
│   │   ├── Counting Sort
│   │   ├── Bucket Sort
│   │   ├── Shell Sort
│   │   ├── Cocktail Shaker Sort
│   │   ├── Comb Sort
│   │   └── Tim Sort
│   ├── Divide and Conquer Algorithms
│   │   ├── Closest Pair
│   │   ├── Convex Hull
│   │   ├── Matrix Multiplication
│   │   └── Strassen's Algorithm
│   ├── Greedy Algorithms
│   │   ├── Activity Selection
│   │   ├── Fractional Knapsack
│   │   ├── Huffman Coding
│   │   ├── Interval Scheduling
│   │   ├── Job Sequencing
│   │   ├── Minimum Spanning Tree
│   │   ├── Prim's Algorithm
│   │   ├── Kruskal's Algorithm
│   │   ├── Dijkstra's Algorithm
│   │   ├── Greedy Coloring
│   │   ├── Greedy Scheduling
│   │   └── Greedy Set Cover
│   ├── Recursion
│   │   ├── Tail Recursion
│   │   ├── Head Recursion
│   │   ├── Tree Recursion
│   │   ├── Indirect Recursion
│   │   ├── Nested Recursion
│   │   └── Mutual Recursion
│   ├── Backtracking Algorithms
│   │   ├── N-Queens Problem
│   │   ├── Sudoku Solver
│   │   ├── Hamiltonian Cycle
│   │   ├── Graph Coloring
│   │   └── Subset Sum
│   ├── Dynamic Programming
│   │   ├── Fibonacci Series
│   │   ├── Longest Common Subsequence (LCS)
│   │   ├── 0/1 Knapsack
│   │   ├── Matrix Chain Multiplication (MCM)
│   │   ├── Longest Increasing Subsequence (LIS)
│   │   ├── Edit Distance
│   │   ├── Coin Change
│   │   ├── Rod Cutting
│   │   ├── Subset Sum
│   │   ├── Binomial Coefficient
│   │   ├── Tiling Problems
│   │   ├── Knapsack with Duplicate Items
│   │   ├── Knapsack with Fractional Items
│   │   ├── Palindrome Partitioning
│   │   ├── Boolean Parenthesization
│   │   └── Maximum Subarray Sum
│   ├── Pattern Searching
│   │   ├── Naive Pattern Searching
│   │   ├── Knuth-Morris-Pratt (KMP) Algorithm
│   │   ├── Rabin-Karp Algorithm
│   │   ├── Boyer-Moore Algorithm
│   │   ├── Finite Automaton
│   │   ├── Suffix Array
│   │   └── Suffix Automaton
│   ├── Mathematical Algorithms
│   │   ├── Prime Numbers
│   │   ├── Sieve of Eratosthenes
│   │   ├── Euclidean Algorithm
│   │   ├── Extended Euclidean Algorithm
│   │   ├── Modular Exponentiation
│   │   ├── Chinese Remainder Theorem
│   │   ├── Euler's Totient Function
│   │   ├── Fermat's Little Theorem
│   │   ├── Modular Inverse
│   │   ├── Primality Testing
│   │   ├── Factorial
│   │   ├── Permutation
│   │   ├── Combination
│   │   ├── Catalan Numbers
│   │   └── Binomial Coefficients
│   ├── Geometric Algorithms
│   │   ├── Point Representation
│   │   ├── Line Representation
│   │   ├── Convex Hull
│   │   ├── Closest Pair of Points
│   │   ├── Line Intersection
│   │   ├── Polygon Triangulation
│   │   └── Sweep Line Algorithm
│   ├── Bitwise Algorithms
│   │   ├── Bit Manipulation Basics
│   │   ├── Bitwise Operators
│   │   ├── Bitwise Operations on Integers
│   │   ├── Bitwise Operations on Floating-Point Numbers
│   │   ├── Bit Hacks
│   │   ├── Counting Bits
│   │   ├── Finding Missing Number
│   │   ├── Detecting Duplicates
│   │   ├── Finding Odd/Even Occurrences
│   │   └── Bitwise Tricks
│   ├── Graph Algorithms
│   │   ├── Depth-First Search (DFS)
│   │   ├── Breadth-First Search (BFS)
│   │   ├── Dijkstra's Algorithm
│   │   ├── Bellman-Ford Algorithm
│   │   ├── Kruskal's Algorithm
│   │   ├── Prim's Algorithm
│   │   ├── Floyd-Warshall Algorithm
│   │   ├── Topological Sorting
│   │   ├── Minimum Spanning Tree (MST)
│   │   ├── Strongly Connected Components (SCC)
│   │   ├── Articulation Points
│   │   └── Bridges
│   ├── Randomized Algorithms
│   ├── Branch and Bound Algorithms
│   ├── Randomized Algorithms
│   ├── Approximation Algorithms
│   └── Cryptographic Algorithms
│   └── Approximation Algorithms
└── Practice Problems on DSA
```
